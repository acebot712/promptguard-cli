/// Runtime shim templates for different languages and providers
///
/// These templates are embedded at compile time and used to generate
/// runtime interception code that ensures all SDK calls route through
/// `PromptGuard`, regardless of how the SDK is initialized.
use crate::types::Provider;

/// Python runtime shim template
///
/// This template monkey-patches SDK constructors to automatically inject
/// the `PromptGuard` proxy URL if not already configured.
pub const PYTHON_SHIM_TEMPLATE: &str = r#"#!/usr/bin/env python3
"""
PromptGuard Runtime Shim - Auto-generated
DO NOT EDIT THIS FILE MANUALLY

This module intercepts LLM SDK initialization to ensure all API calls
route through PromptGuard for security monitoring and protection.

Installation is automatic - this file is imported by your application
entry points to enable runtime protection.
"""

import os
import sys
import warnings
from typing import Any, Dict, Optional

# Store original SDK classes to avoid circular dependencies
_original_classes: Dict[str, Any] = {}
_shimmed_providers: set = set()

# Configuration
PROXY_URL = os.environ.get("PROMPTGUARD_PROXY_URL", "{{PROXY_URL}}")
API_KEY_VAR = os.environ.get("PROMPTGUARD_API_KEY_VAR", "{{API_KEY_VAR}}")
ENABLED = os.environ.get("PROMPTGUARD_ENABLED", "true").lower() in ("true", "1", "yes")

# Debug mode for troubleshooting
DEBUG = os.environ.get("PROMPTGUARD_DEBUG", "false").lower() in ("true", "1", "yes")


def _debug(msg: str) -> None:
    """Print debug message if DEBUG mode is enabled."""
    if DEBUG:
        print(f"[PromptGuard Shim] {msg}", file=sys.stderr)


def _ensure_base_url(kwargs: Dict[str, Any], provider: str, param_name: str = "base_url") -> Dict[str, Any]:
    """
    Ensure base_url is set to PromptGuard proxy if not already configured.

    Args:
        kwargs: Constructor keyword arguments
        provider: Provider name (for logging)
        param_name: Parameter name for base URL (default: base_url)

    Returns:
        Modified kwargs with base_url injected if needed
    """
    if not ENABLED:
        _debug(f"PromptGuard disabled, skipping {provider} interception")
        return kwargs

    if param_name in kwargs:
        current_url = kwargs[param_name]
        _debug(f"{provider}: base_url already set to {current_url}")
        return kwargs

    # Inject PromptGuard proxy URL
    kwargs = kwargs.copy()
    kwargs[param_name] = PROXY_URL
    _debug(f"{provider}: injected base_url={PROXY_URL}")

    return kwargs


{{PROVIDER_PATCHES}}


def _install_shims() -> None:
    """Install all runtime shims for detected providers."""
    providers_shimmed = []

    {{INSTALL_CALLS}}

    if providers_shimmed:
        _debug(f"Installed shims for: {', '.join(providers_shimmed)}")
    else:
        _debug("No LLM SDKs found to shim")


# Auto-install shims when module is imported
_install_shims()
"#;

/// `OpenAI` Python provider patch template
pub const PYTHON_OPENAI_PATCH: &str = r#"
def _shim_openai() -> None:
    """Monkey-patch OpenAI SDK."""
    if "openai" in _shimmed_providers:
        return

    try:
        import openai

        # Store original class
        if "OpenAI" not in _original_classes:
            _original_classes["OpenAI"] = openai.OpenAI

        original_openai = _original_classes["OpenAI"]

        class PatchedOpenAI(original_openai):
            """PromptGuard-wrapped OpenAI client."""

            def __init__(self, **kwargs):
                kwargs = _ensure_base_url(kwargs, "OpenAI", "base_url")
                super().__init__(**kwargs)

        # Apply monkey-patch
        openai.OpenAI = PatchedOpenAI
        _shimmed_providers.add("openai")
        _debug("OpenAI SDK shimmed successfully")

    except ImportError:
        _debug("OpenAI SDK not installed, skipping")
    except Exception as e:
        warnings.warn(f"Failed to shim OpenAI SDK: {e}", RuntimeWarning)
"#;

/// Anthropic Python provider patch template
pub const PYTHON_ANTHROPIC_PATCH: &str = r#"
def _shim_anthropic() -> None:
    """Monkey-patch Anthropic SDK."""
    if "anthropic" in _shimmed_providers:
        return

    try:
        import anthropic

        # Store original class
        if "Anthropic" not in _original_classes:
            _original_classes["Anthropic"] = anthropic.Anthropic

        original_anthropic = _original_classes["Anthropic"]

        class PatchedAnthropic(original_anthropic):
            """PromptGuard-wrapped Anthropic client."""

            def __init__(self, **kwargs):
                kwargs = _ensure_base_url(kwargs, "Anthropic", "base_url")
                super().__init__(**kwargs)

        # Apply monkey-patch
        anthropic.Anthropic = PatchedAnthropic
        _shimmed_providers.add("anthropic")
        _debug("Anthropic SDK shimmed successfully")

    except ImportError:
        _debug("Anthropic SDK not installed, skipping")
    except Exception as e:
        warnings.warn(f"Failed to shim Anthropic SDK: {e}", RuntimeWarning)
"#;

/// Cohere Python provider patch template
pub const PYTHON_COHERE_PATCH: &str = r#"
def _shim_cohere() -> None:
    """Monkey-patch Cohere SDK."""
    if "cohere" in _shimmed_providers:
        return

    try:
        import cohere

        # Store original class
        if "CohereClient" not in _original_classes:
            _original_classes["CohereClient"] = cohere.Client

        original_cohere = _original_classes["CohereClient"]

        class PatchedCohereClient(original_cohere):
            """PromptGuard-wrapped Cohere client."""

            def __init__(self, **kwargs):
                kwargs = _ensure_base_url(kwargs, "Cohere", "base_url")
                super().__init__(**kwargs)

        # Apply monkey-patch
        cohere.Client = PatchedCohereClient
        _shimmed_providers.add("cohere")
        _debug("Cohere SDK shimmed successfully")

    except ImportError:
        _debug("Cohere SDK not installed, skipping")
    except Exception as e:
        warnings.warn(f"Failed to shim Cohere SDK: {e}", RuntimeWarning)
"#;

/// `HuggingFace` Python provider patch template
pub const PYTHON_HUGGINGFACE_PATCH: &str = r#"
def _shim_huggingface() -> None:
    """Monkey-patch HuggingFace InferenceClient."""
    if "huggingface" in _shimmed_providers:
        return

    try:
        from huggingface_hub import InferenceClient
        import huggingface_hub

        # Store original class
        if "InferenceClient" not in _original_classes:
            _original_classes["InferenceClient"] = InferenceClient

        original_hf = _original_classes["InferenceClient"]

        class PatchedInferenceClient(original_hf):
            """PromptGuard-wrapped HuggingFace InferenceClient."""

            def __init__(self, **kwargs):
                kwargs = _ensure_base_url(kwargs, "HuggingFace", "base_url")
                super().__init__(**kwargs)

        # Apply monkey-patch
        huggingface_hub.InferenceClient = PatchedInferenceClient
        _shimmed_providers.add("huggingface")
        _debug("HuggingFace SDK shimmed successfully")

    except ImportError:
        _debug("HuggingFace SDK not installed, skipping")
    except Exception as e:
        warnings.warn(f"Failed to shim HuggingFace SDK: {e}", RuntimeWarning)
"#;

/// TypeScript/JavaScript runtime shim template
pub const TYPESCRIPT_SHIM_TEMPLATE: &str = r#"/**
 * PromptGuard Runtime Shim - Auto-generated
 * DO NOT EDIT THIS FILE MANUALLY
 *
 * This module intercepts LLM SDK initialization to ensure all API calls
 * route through PromptGuard for security monitoring and protection.
 */

const PROXY_URL = process.env.PROMPTGUARD_PROXY_URL || "{{PROXY_URL}}";
const API_KEY_VAR = process.env.PROMPTGUARD_API_KEY_VAR || "{{API_KEY_VAR}}";
const ENABLED = (process.env.PROMPTGUARD_ENABLED || "true").toLowerCase() !== "false";
const DEBUG = (process.env.PROMPTGUARD_DEBUG || "false").toLowerCase() === "true";

function debug(msg: string): void {
  if (DEBUG) {
    console.error(`[PromptGuard Shim] ${msg}`);
  }
}

function ensureBaseURL<T extends Record<string, any>>(
  config: T | undefined,
  provider: string,
  paramName: string = "baseURL"
): T {
  if (!ENABLED) {
    debug(`PromptGuard disabled, skipping ${provider} interception`);
    return config || ({} as T);
  }

  const cfg = config || ({} as T);

  if (paramName in cfg) {
    debug(`${provider}: ${paramName} already set to ${cfg[paramName]}`);
    return cfg;
  }

  // Inject PromptGuard proxy URL
  const modified = { ...cfg, [paramName]: PROXY_URL };
  debug(`${provider}: injected ${paramName}=${PROXY_URL}`);

  return modified;
}

{{PROVIDER_EXPORTS}}
"#;

/// `OpenAI` TypeScript provider export template
pub const TYPESCRIPT_OPENAI_EXPORT: &str = r#"
// OpenAI SDK wrapper
let OriginalOpenAI: any = null;

try {
  const openaiModule = require("openai");
  OriginalOpenAI = openaiModule.OpenAI || openaiModule.default?.OpenAI;

  if (OriginalOpenAI) {
    export class OpenAI extends OriginalOpenAI {
      constructor(config?: any) {
        const modifiedConfig = ensureBaseURL(config, "OpenAI", "baseURL");
        super(modifiedConfig);
      }
    }
    debug("OpenAI SDK shimmed successfully");
  } else {
    debug("OpenAI class not found in module");
  }
} catch (e) {
  debug(`OpenAI SDK not available: ${e}`);
  // Re-export empty class as fallback
  export class OpenAI {
    constructor() {
      throw new Error("OpenAI SDK not installed");
    }
  }
}
"#;

/// Anthropic TypeScript provider export template
pub const TYPESCRIPT_ANTHROPIC_EXPORT: &str = r#"
// Anthropic SDK wrapper
let OriginalAnthropic: any = null;

try {
  const anthropicModule = require("@anthropic-ai/sdk");
  OriginalAnthropic = anthropicModule.Anthropic || anthropicModule.default?.Anthropic;

  if (OriginalAnthropic) {
    export class Anthropic extends OriginalAnthropic {
      constructor(config?: any) {
        const modifiedConfig = ensureBaseURL(config, "Anthropic", "baseURL");
        super(modifiedConfig);
      }
    }
    debug("Anthropic SDK shimmed successfully");
  } else {
    debug("Anthropic class not found in module");
  }
} catch (e) {
  debug(`Anthropic SDK not available: ${e}`);
  // Re-export empty class as fallback
  export class Anthropic {
    constructor() {
      throw new Error("Anthropic SDK not installed");
    }
  }
}
"#;

/// Cohere TypeScript provider export template
pub const TYPESCRIPT_COHERE_EXPORT: &str = r#"
// Cohere SDK wrapper
let OriginalCohereClient: any = null;

try {
  const cohereModule = require("cohere-ai");
  OriginalCohereClient = cohereModule.CohereClient || cohereModule.default?.CohereClient;

  if (OriginalCohereClient) {
    export class CohereClient extends OriginalCohereClient {
      constructor(config?: any) {
        const modifiedConfig = ensureBaseURL(config, "Cohere", "baseURL");
        super(modifiedConfig);
      }
    }
    debug("Cohere SDK shimmed successfully");
  } else {
    debug("CohereClient class not found in module");
  }
} catch (e) {
  debug(`Cohere SDK not available: ${e}`);
  // Re-export empty class as fallback
  export class CohereClient {
    constructor() {
      throw new Error("Cohere SDK not installed");
    }
  }
}
"#;

/// `HuggingFace` TypeScript provider export template
pub const TYPESCRIPT_HUGGINGFACE_EXPORT: &str = r#"
// HuggingFace SDK wrapper
let OriginalHfInference: any = null;

try {
  const hfModule = require("@huggingface/inference");
  OriginalHfInference = hfModule.HfInference || hfModule.default?.HfInference;

  if (OriginalHfInference) {
    export class HfInference extends OriginalHfInference {
      constructor(config?: any) {
        const modifiedConfig = ensureBaseURL(config, "HuggingFace", "baseUrl");
        super(modifiedConfig);
      }
    }
    debug("HuggingFace SDK shimmed successfully");
  } else {
    debug("HfInference class not found in module");
  }
} catch (e) {
  debug(`HuggingFace SDK not available: ${e}`);
  // Re-export empty class as fallback
  export class HfInference {
    constructor() {
      throw new Error("HuggingFace SDK not installed");
    }
  }
}
"#;

/// Get Python provider patch code for a given provider
pub fn get_python_provider_patch(provider: Provider) -> &'static str {
    match provider {
        Provider::OpenAI => PYTHON_OPENAI_PATCH,
        Provider::Anthropic => PYTHON_ANTHROPIC_PATCH,
        Provider::Cohere => PYTHON_COHERE_PATCH,
        Provider::HuggingFace => PYTHON_HUGGINGFACE_PATCH,
    }
}

/// Get Python install call for a given provider
pub fn get_python_install_call(provider: Provider) -> &'static str {
    match provider {
        Provider::OpenAI => "    _shim_openai()\n    providers_shimmed.append('OpenAI')",
        Provider::Anthropic => "    _shim_anthropic()\n    providers_shimmed.append('Anthropic')",
        Provider::Cohere => "    _shim_cohere()\n    providers_shimmed.append('Cohere')",
        Provider::HuggingFace => {
            "    _shim_huggingface()\n    providers_shimmed.append('HuggingFace')"
        },
    }
}

/// Get TypeScript provider export code for a given provider
pub fn get_typescript_provider_export(provider: Provider) -> &'static str {
    match provider {
        Provider::OpenAI => TYPESCRIPT_OPENAI_EXPORT,
        Provider::Anthropic => TYPESCRIPT_ANTHROPIC_EXPORT,
        Provider::Cohere => TYPESCRIPT_COHERE_EXPORT,
        Provider::HuggingFace => TYPESCRIPT_HUGGINGFACE_EXPORT,
    }
}
